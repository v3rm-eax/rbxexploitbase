#pragma once
#include "minwindef.h"


inline long fuck(long Address) { //aslr
	return (Address + (DWORD)GetModuleHandle(0));
}



DWORD retcheck(DWORD addr) //credits to eternal for the working returncheck bypass
{
	BYTE* tAddr = (BYTE *)addr;

	do {
		tAddr += 0x10;
	} while (!(tAddr[0] == 0x55 && tAddr[1] == 0x8B && tAddr[2] == 0xEC));

	DWORD funcSz = tAddr - (BYTE*)addr;

	PVOID nFunc = VirtualAlloc(NULL, funcSz, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (nFunc == NULL)
		return addr;

	memcpy(nFunc, (void*)addr, funcSz);

	DWORD pos = (DWORD)nFunc;
	BOOL valid = false;
	do {
		if (*(BYTE*)pos == 0x72 && *(BYTE*)(pos + 0x2) == 0xA1 && (*(BYTE*)(pos + 0x7)) == 0x8B) {
			memcpy((void*)pos, "\xEB", 1);

			DWORD cNFunc = (DWORD)nFunc;
			do {
				if (*(BYTE*)cNFunc == 0xE8)
				{
					DWORD tFunc = addr + (cNFunc - (DWORD)nFunc);
					DWORD oFunc = (tFunc + *(DWORD*)(tFunc + 1)) + 5;

					if (oFunc % 16 == 0)
					{
						DWORD realCAddr = oFunc - cNFunc - 5;
						*(DWORD*)(cNFunc + 1) = realCAddr;
					}
					cNFunc += 5;
				}
				else
					cNFunc += 1;
			} while (cNFunc - (DWORD)nFunc < funcSz);

			valid = true;
		}
		pos += 1;
	} while (pos < (DWORD)nFunc + funcSz);

	if (!valid) {
		VirtualFree(nFunc, funcSz, MEM_RELEASE);
		return addr;
	}

	return (DWORD)nFunc;
}

DWORD DataModel; //define datamodel
int ScriptContext;//define scriptcontext as an integer
DWORD Players; //define players
DWORD Workspace; //workspace
int LuaState; //luastate as an integer
DWORD LocalPlayer; //localplayer



DWORD ScriptContextAddress = fuck(0x123));
DWORD GetFieldAddress = retcheck(fuck(0x123));
DWORD PushStringAddress = retcheck(fuck(0x123));
DWORD PcallAddress = retcheck(fuck(0x123));
DWORD SetFieldAddress = retcheck(fuck(0x123));
DWORD PushValueAddress = retcheck(fuck(0x123));
DWORD PushNumberAddress = retcheck(fuck(0x123));




typedef void(__cdecl *Lua_getfield)(int lua_State, int index, const char *k); //defining args
Lua_getfield ggetfield = (Lua_getfield)retcheck(fuck(0x123));

typedef void(__cdecl *Lua_setfield)(int lua_State, int index, const char *k);
Lua_setfield ssetfield = (Lua_setfield)retcheck(fuck(0x123));

typedef void(__cdecl *Lua_pushstring)(int lua_State, const char *s); //defining args
Lua_pushstring ppushstring = (Lua_pushstring)retcheck(fuck(0x123));

typedef void(__cdecl *Lua_pushvalue)(int lua_State, int index);
Lua_pushvalue ppushvalue = (Lua_pushvalue)retcheck(fuck(0x123)); //defining args

typedef int(__cdecl *Lua_pcall)(int lua_State, int nargs, int nresults); //defining args
Lua_pcall ppcall = (Lua_pcall)retcheck(fuck(0x123));

typedef int(__cdecl *Lua_pushnumber)(int lua_State, double n); //defining args
Lua_pushnumber ppushnumber = (Lua_pushnumber)retcheck(fuck(0x123));

void getfield(int state, int index, const char *k) { //defining getfield

	ggetfield(state, index, k);

}

inline void getglobal(int state, const char *name) { //defining getglobal
	return ggetfield(state, -1002, name);
}

void setfield(int state, int index, const char *k) {
	ssetfield(state, index, k);
}

void pushstring(int state, const char *s) { //defining pushstring
	ppushstring(state, s);
}

void pushvalue(int state, int index) { //pushvalue
	ppushvalue(state, index);
}

void pcall(int state, int nargs, int nresults) { //pcall
	ppcall(state, nargs, nresults);
}

void pushnumber(int state, double n) { //pushnumber
	ppushnumber(state, n);
}
